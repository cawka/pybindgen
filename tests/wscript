## -*- python -*-
import Action
import Object
import Params
import Task

import sys
import os.path
import os
import pproc as subprocess


def create_pyext_obj(bld, c_or_cpp_type):
    waf_version = [int (s) for s in Params.g_version.split('.')]
    if waf_version >= [1,4]:
        return bld.create_obj(c_or_cpp_type, 'shlib', 'pyext')
    else:
        return bld.create_obj(c_or_cpp_type, 'plugin', 'pyext')


def build(bld):
    top_srcdir = bld.m_srcnode.abspath()

    gen = bld.create_obj('command-output')
    gen.command = 'test-generation.py'
    gen.stdout = 'test.cc'
    gen.argv = [gen.input_file('test-generation.py'), top_srcdir]
    gen.command = bld.env()['PYTHON']
    gen.command_is_external = True
    gen.prio = 55
    
    obj = bld.create_obj('cpp', 'objects', 'pyext')
    obj.source = 'test.cc'
    if os.path.basename(obj.env['CXX']).startswith("g++"):
        obj.env.append_value('CXXFLAGS', ['-Werror', '-Wno-unused'])
    
    ## manual code generation using simple pybindgen API calls
    bindgen = bld.create_obj('command-output')
    bindgen.stdout = 'foomodule.cc'
    bindgen.argv = [bindgen.input_file('foomodulegen.py')]
    bindgen.command = bindgen.env['PYTHON']
    bindgen.command_is_external = True
    bindgen.prio = 55 # must run after the 'py' objects in ../pybindgen

    obj = create_pyext_obj(bld, 'cpp')
    obj.source = [
        'foo.cc',
        'foomodule.cc'
        ]
    obj.target = 'foo'
    obj.inst_var = 0 # do not install
    obj.includes = '.'

    ## automatic code scanning using gccxml
    if bld.env()['ENABLE_PYGCCXML']:
        ### Same thing, but using gccxml autoscanning
        bindgen = bld.create_obj('command-output')
        bindgen.stdout = 'foomodule2.cc'
        bindgen.argv = [bindgen.input_file('foomodulegen-auto.py'),
                        bindgen.input_file('foo.h'),
                        bindgen.output_file('foomodulegen_generated.py')]
        bindgen.command = bindgen.env['PYTHON']
        bindgen.command_is_external = True
        bindgen.prio = 55 # must run after the 'py' objects in ../pybindgen

        obj = create_pyext_obj(bld, 'cpp')
        obj.source = [
            'foo.cc',
            'foomodule2.cc'
            ]
        obj.target = 'foo2'
        obj.inst_var = 0 # do not install
        obj.includes = '.'


        ### Now using the generated python script
        bindgen = bld.create_obj('command-output')
        bindgen.stdout = 'foomodule3.cc'
        bindgen.argv = [bindgen.input_file('foomodulegen3.py'),
                        bindgen.output_file('foomodule3.cc')]
        bindgen.command = bindgen.env['PYTHON']
        bindgen.command_is_external = True
        bindgen.prio = 56 # run after the previous bindgen

        ## yes, this global manipulation of PYTHONPATH is kind of evil :-/
        ## TODO: add WAF command-output support for customising command OS environment
        os.environ["PYTHONPATH"] = os.pathsep.join([os.environ.get("PYTHONPATH", ''), bindgen.path.abspath(bindgen.env)])

        obj = create_pyext_obj(bld, 'cpp')
        obj.source = [
            'foo.cc',
            'foomodule3.cc'
            ]
        obj.target = 'foo3'
        obj.inst_var = 0 # do not install
        obj.includes = '.'

    ## pure C tests
    bld.add_subdirs('c-hello')

