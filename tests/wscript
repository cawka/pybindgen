## -*- python -*-
import Action
import Object
import Params
import Task

import sys
import os.path
import os
import pproc as subprocess

# uncomment to enable profiling information
# epydoc uses the profile data to generate call graphs
#os.environ["PYBINDGEN_ENABLE_PROFILING"] = ""


def create_pyext_obj(bld, c_or_cpp_type):
    waf_version = [int (s) for s in Params.g_version.split('.')]
    if waf_version >= [1,4]:
        return bld.create_obj(c_or_cpp_type, 'shlib', 'pyext')
    else:
        return bld.create_obj(c_or_cpp_type, 'plugin', 'pyext')


if 1:
    DEPRECATION_ERRORS = '-Werror::DeprecationWarning' # deprecations become errors
else:
    DEPRECATION_ERRORS = '-Wdefault::DeprecationWarning' # normal python behaviour


def build(bld):
    top_srcdir = bld.m_srcnode.abspath()

    gen = bld.create_obj('command-output')
    gen.command = 'test-generation.py'
    gen.stdout = 'test.cc'
    gen.argv = [gen.input_file('test-generation.py'), top_srcdir]
    gen.command = bld.env()['PYTHON']
    gen.command_is_external = True
    gen.prio = 55
    
    obj = bld.create_obj('cpp', 'objects', 'pyext')
    obj.source = 'test.cc'
    if os.path.basename(obj.env['CXX']).startswith("g++"):
        obj.env.append_value('CXXFLAGS', ['-Werror', '-Wno-unused'])
    
    ## manual code generation using simple pybindgen API calls
    bindgen = bld.create_obj('command-output')
    bindgen.stdout = 'foomodule.cc'
    bindgen.argv = [
        DEPRECATION_ERRORS,
        bindgen.input_file('foomodulegen.py'),
        ]
    bindgen.command = bindgen.env['PYTHON']
    bindgen.command_is_external = True
    bindgen.prio = 55 # must run after the 'py' objects in ../pybindgen

    obj = create_pyext_obj(bld, 'cpp')
    obj.source = [
        'foo.cc',
        'foomodule.cc'
        ]
    obj.target = 'foo'
    obj.inst_var = 0 # do not install
    obj.includes = '.'

    ## automatic code scanning using gccxml
    if bld.env()['ENABLE_PYGCCXML']:
        ### Same thing, but using gccxml autoscanning
        bindgen = bld.create_obj('command-output')
        bindgen.stdout = 'foomodule2.cc'
        bindgen.argv = [
            DEPRECATION_ERRORS,
            bindgen.input_file('foomodulegen-auto.py'),
            bindgen.input_file('foo.h'),
            repr(bindgen.env['CPPPATH_PYEXT']),
            bindgen.output_file('foomodulegen_generated.py'),
            ]
        bindgen.command = bindgen.env['PYTHON']
        bindgen.command_is_external = True
        bindgen.prio = 55 # must run after the 'py' objects in ../pybindgen

        ### Now using the generated python script
        bindgen = bld.create_obj('command-output')
        bindgen.stdout = 'foomodule3.cc'
        bindgen.argv = [
            DEPRECATION_ERRORS,
            bindgen.input_file('foomodulegen3.py'),
            bindgen.output_file('foomodule3.cc'),
            ]
        bindgen.command = bindgen.env['PYTHON']
        bindgen.command_is_external = True
        bindgen.prio = 56 # run after the previous bindgen

        ## yes, this global manipulation of PYTHONPATH is kind of evil :-/
        ## TODO: add WAF command-output support for customising command OS environment
        os.environ["PYTHONPATH"] = os.pathsep.join([os.environ.get("PYTHONPATH", ''), bindgen.path.abspath(bindgen.env)])

        obj = create_pyext_obj(bld, 'cpp')
        obj.source = [
            'foo.cc',
            'foomodule3.cc'
            ]
        obj.target = 'foo3'
        obj.inst_var = 0 # do not install
        obj.includes = '.'

        ## ---

        ### using gccxml autoscanning, but split the generated python script into modules
        bindgen = bld.create_obj('command-output')
        bindgen.argv = [
            DEPRECATION_ERRORS,
            bindgen.input_file('foomodulegen-auto-split.py'),
            bindgen.input_file('foo.h'),
            repr(bindgen.env['CPPPATH_PYEXT']),
            bindgen.output_file('foomodulegen_split.py'),
            bindgen.output_file('foomodulegen_module1.py'),
            bindgen.output_file('foomodulegen_module2.py'),
            ]
        bindgen.command = bindgen.env['PYTHON']
        bindgen.command_is_external = True
        bindgen.prio = 55 # must run after the 'py' objects in ../pybindgen

        obj = create_pyext_obj(bld, 'cpp')
        obj.source = [
            'foo.cc',
            'foomodule2.cc'
            ]
        obj.target = 'foo2'
        obj.inst_var = 0 # do not install
        obj.includes = '.'

        ### Run the generated python script with split modules
        bindgen = bld.create_obj('command-output')
        bindgen.argv = [
            DEPRECATION_ERRORS,
            bindgen.input_file('foomodulegen4.py'),
            bindgen.output_file('foomodule4.cc'),
            ]
        bindgen.command = bindgen.env['PYTHON']
        bindgen.command_is_external = True
        bindgen.prio = 56 # run after the previous bindgen
        bindgen.hidden_inputs = [
            'foomodulegen_split.py',
            'foomodulegen_module1.py',
            'foomodulegen_module2.py',
            ]
        bindgen.hidden_outputs = [
            'foomodule4.h',
            'foomodulegen_module1.cc',
            'foomodulegen_module2.cc',
            ]

        obj = create_pyext_obj(bld, 'cpp')
        obj.source = [
            'foo.cc',
            'foomodule4.cc',
            'foomodulegen_module1.cc',
            'foomodulegen_module2.cc',
            ]
        obj.target = 'foo4'
        obj.inst_var = 0 # do not install
        obj.includes = '.'

    ## pure C tests
    bld.add_subdirs('c-hello')

